{"version":3,"sources":["turbopack:///[project]/src/lib/auth/session.ts","turbopack:///[project]/src/lib/prisma.ts","turbopack:///[project]/src/lib/utils/validation.ts","turbopack:///[project]/src/lib/auth/password.ts","turbopack:///[project]/src/backend/jobs/fetchTodaySleepRaw.ts","turbopack:///[project]/src/backend/jobs/sleepSessionDetector.ts","turbopack:///[project]/src/lib/sleep/calculateDailySleepScore.ts","turbopack:///[project]/src/backend/jobs/calcTodaySleepScore.ts"],"sourcesContent":["// src/lib/auth/session.ts\n/**\n * 세션 관리 유틸리티\n * \n * NextAuth 세션 검증 및 목업 모드 확인\n */\n\nimport { getServerSession } from \"next-auth\";\nimport { NextResponse } from \"next/server\";\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\nimport { isMockMode } from \"./mockMode\";\n\n/**\n * 세션 타입 정의\n */\nexport interface AuthSession {\n  user: {\n    id: string;\n    email: string;\n    name?: string | null;\n    image?: string | null;\n  };\n}\n\n/**\n * 인증이 필요한 API에서 세션을 가져오고 검증\n * \n * @returns 세션 객체 또는 401 응답\n */\nexport async function requireAuth(): Promise<AuthSession | NextResponse> {\n  const session = await getServerSession(authOptions);\n\n  if (!session || !session.user) {\n    return NextResponse.json(\n      { error: \"UNAUTHORIZED\", message: \"인증이 필요합니다.\" },\n      { status: 401 }\n    );\n  }\n\n  // NextAuth 세션에서 id 추출 (JWT 콜백에서 설정됨)\n  const userId = (session.user as { id?: string }).id;\n  if (!userId) {\n    return NextResponse.json(\n      { error: \"UNAUTHORIZED\", message: \"인증이 필요합니다.\" },\n      { status: 401 }\n    );\n  }\n\n  return {\n    user: {\n      id: userId,\n      email: session.user.email || \"\",\n      name: session.user.name || null,\n      image: session.user.image || null,\n    },\n  };\n}\n\n/**\n * 목업 모드 여부 확인\n * \n * @param session - AuthSession 또는 NextAuth 세션 객체\n * @returns 목업 모드 여부\n */\nexport function checkMockMode(session: AuthSession | { user?: { email?: string; id?: string } } | null): boolean {\n  if (!session || !session.user) {\n    return false;\n  }\n  return isMockMode(session as { user?: { email?: string; id?: string } });\n}\n","// src/lib/prisma.ts\n/**\n * [파일 역할]\n * - Prisma Client 싱글톤 인스턴스를 생성하고 export 합니다.\n * - Next.js 개발 환경에서 HMR(Hot Module Replacement)로 인한\n *   Prisma Client 중복 생성을 방지합니다.\n *\n * [사용되는 위치]\n * - 모든 API Route Handler에서 import하여 DB 작업 수행\n * - 예: import { prisma } from \"@/lib/prisma\";\n *\n * [주의사항]\n * - Prisma Client는 서버 사이드에서만 사용 가능 (클라이언트 컴포넌트에서 사용 금지)\n * - DATABASE_URL 환경 변수 필수\n */\n\nimport { PrismaClient } from \"@prisma/client\";\n\n// Prisma Client 전역 타입 선언 (개발 환경 HMR 대응)\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\n/**\n * Prisma Client 싱글톤 생성\n * - 개발 환경: globalThis에 저장하여 HMR 시에도 재사용\n * - 프로덕션: 매번 새 인스턴스 생성 (서버리스 환경 대응)\n */\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\n// 개발 환경에서만 globalThis에 저장\nif (process.env.NODE_ENV !== \"production\") {\n  globalForPrisma.prisma = prisma;\n}\n\n/**\n * Prisma Client 연결 종료\n * - Next.js는 자동으로 연결을 관리하므로 일반적으로 호출 불필요\n * - 특수한 경우(테스트, 스크립트 등)에만 사용\n */\nexport async function disconnectPrisma() {\n  await prisma.$disconnect();\n}\n","// src/lib/utils/validation.ts\n/**\n * [파일 역할]\n * - API 요청 데이터 검증 유틸리티 함수 제공\n * - 이메일, 날짜, 디바이스 타입 등 공통 검증 로직\n *\n * [사용되는 위치]\n * - 모든 API Route Handler에서 요청 검증 시 사용\n * - 회원가입, 디바이스 생성, 무드 변경 등\n *\n * [주의사항]\n * - 클라이언트 검증과 별개로 서버 사이드에서도 반드시 검증 필요\n * - 보안 취약점 방지를 위해 모든 입력값 검증\n */\n\n/**\n * 이메일 형식을 검증합니다.\n *\n * @param email - 검증할 이메일 주소\n * @returns 유효 여부 (true/false)\n *\n * @example\n * if (!isValidEmail(\"test@example.com\")) {\n *   return NextResponse.json({ error: \"Invalid email\" }, { status: 400 });\n * }\n */\nexport function isValidEmail(email: string): boolean {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\n/**\n * 날짜 형식을 검증합니다 (YYYY-MM-DD).\n *\n * @param date - 검증할 날짜 문자열\n * @returns 유효 여부 (true/false)\n *\n * @example\n * if (!isValidDate(\"1990-01-01\")) {\n *   return NextResponse.json({ error: \"Invalid date format\" }, { status: 400 });\n * }\n */\nexport function isValidDate(date: string): boolean {\n  const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  if (!dateRegex.test(date)) {\n    return false;\n  }\n\n  // 실제 유효한 날짜인지 확인\n  const parsedDate = new Date(date);\n  return !isNaN(parsedDate.getTime());\n}\n\n/**\n * 만 나이를 계산합니다.\n *\n * @param birthDate - 생년월일 (YYYY-MM-DD)\n * @returns 만 나이\n *\n * @example\n * const age = calculateAge(\"1990-01-01\");\n * if (age < 12) {\n *   return NextResponse.json({ error: \"Must be 12 or older\" }, { status: 400 });\n * }\n */\nexport function calculateAge(birthDate: string): number {\n  const today = new Date();\n  const birth = new Date(birthDate);\n  let age = today.getFullYear() - birth.getFullYear();\n  const monthDiff = today.getMonth() - birth.getMonth();\n\n  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {\n    age--;\n  }\n\n  return age;\n}\n\n/**\n * 디바이스 타입이 유효한지 검증합니다.\n *\n * @param type - 검증할 디바이스 타입\n * @returns 유효 여부 (true/false)\n *\n * @example\n * if (!isValidDeviceType(\"manager\")) {\n *   return NextResponse.json({ error: \"Invalid device type\" }, { status: 400 });\n * }\n */\nexport function isValidDeviceType(type: string): boolean {\n  const validTypes = [\"manager\", \"light\", \"scent\", \"speaker\"];\n  return validTypes.includes(type);\n}\n\n/**\n * 성별이 유효한지 검증합니다.\n *\n * @param gender - 검증할 성별\n * @returns 유효 여부 (true/false)\n *\n * @example\n * if (!isValidGender(\"male\")) {\n *   return NextResponse.json({ error: \"Invalid gender\" }, { status: 400 });\n * }\n */\nexport function isValidGender(gender: string): boolean {\n  const validGenders = [\"male\", \"female\"];\n  return validGenders.includes(gender.toLowerCase());\n}\n\n/**\n * 센트 분사 주기가 유효한지 검증합니다.\n *\n * @param interval - 검증할 분사 주기 (분 단위)\n * @returns 유효 여부 (true/false)\n *\n * @example\n * if (!isValidScentInterval(30)) {\n *   return NextResponse.json({ error: \"Invalid scent interval\" }, { status: 400 });\n * }\n */\nexport function isValidScentInterval(interval: number): boolean {\n  const validIntervals = [5, 10, 15, 20, 25, 30];\n  return validIntervals.includes(interval);\n}\n\n/**\n * 필수 필드가 모두 존재하는지 검증합니다.\n *\n * @param body - 검증할 객체\n * @param requiredFields - 필수 필드명 배열\n * @returns 검증 결과 { valid: boolean, missingFields?: string[] }\n *\n * @example\n * const result = validateRequiredFields(body, [\"email\", \"password\"]);\n * if (!result.valid) {\n *   return NextResponse.json(\n *     { error: `Missing fields: ${result.missingFields?.join(\", \")}` },\n *     { status: 400 }\n *   );\n * }\n */\nexport function validateRequiredFields(\n  body: Record<string, unknown>,\n  requiredFields: string[]\n): { valid: boolean; missingFields?: string[] } {\n  const missingFields = requiredFields.filter(\n    (field) => !body[field] || body[field] === \"\"\n  );\n\n  if (missingFields.length > 0) {\n    return { valid: false, missingFields };\n  }\n\n  return { valid: true };\n}\n\n/**\n * 문자열 길이를 검증합니다.\n *\n * @param value - 검증할 문자열\n * @param min - 최소 길이\n * @param max - 최대 길이\n * @returns 유효 여부 (true/false)\n *\n * @example\n * if (!isValidLength(deviceName, 1, 50)) {\n *   return NextResponse.json(\n *     { error: \"Device name must be 1-50 characters\" },\n *     { status: 400 }\n *   );\n * }\n */\nexport function isValidLength(\n  value: string,\n  min: number,\n  max: number\n): boolean {\n  return value.length >= min && value.length <= max;\n}\n\n/**\n * 전화번호를 정규화합니다.\n * - 하이픈(-), 공백, 괄호 제거\n * - +82 국가코드를 0으로 변환\n * - 숫자만 남김\n *\n * @param phone - 정규화할 전화번호\n * @returns 정규화된 전화번호 (예: \"01012345678\")\n *\n * @example\n * normalizePhoneNumber(\"+82 10-1234-5678\") // \"01012345678\"\n * normalizePhoneNumber(\"010-1234-5678\")    // \"01012345678\"\n * normalizePhoneNumber(\"010 1234 5678\")    // \"01012345678\"\n */\nexport function normalizePhoneNumber(phone: string): string {\n  if (!phone) return \"\";\n\n  // 1. 공백, 하이픈, 괄호 제거\n  let normalized = phone.replace(/[\\s\\-()]/g, \"\");\n\n  // 2. +82 국가코드 처리 (한국)\n  if (normalized.startsWith(\"+82\")) {\n    normalized = \"0\" + normalized.substring(3);\n  } else if (normalized.startsWith(\"82\")) {\n    normalized = \"0\" + normalized.substring(2);\n  }\n\n  // 3. 숫자만 남김\n  normalized = normalized.replace(/\\D/g, \"\");\n\n  return normalized;\n}\n\n/**\n * 한국 전화번호 형식이 유효한지 검증합니다.\n * - 010, 011, 016, 017, 018, 019로 시작\n * - 총 10자리 또는 11자리 숫자\n *\n * @param phone - 검증할 전화번호 (정규화된 형식)\n * @returns 유효 여부 (true/false)\n *\n * @example\n * if (!isValidPhoneNumber(\"01012345678\")) {\n *   return NextResponse.json({ error: \"Invalid phone number\" }, { status: 400 });\n * }\n */\nexport function isValidPhoneNumber(phone: string): boolean {\n  if (!phone) return false;\n\n  // 정규화\n  const normalized = normalizePhoneNumber(phone);\n\n  // 한국 휴대폰 번호 형식: 010, 011, 016, 017, 018, 019로 시작, 10~11자리\n  const phoneRegex = /^01[0|1|6|7|8|9]\\d{7,8}$/;\n  return phoneRegex.test(normalized);\n}\n","// src/lib/auth/password.ts\n/**\n * [파일 역할]\n * - 비밀번호 해싱 및 검증 유틸리티 함수 제공\n * - bcrypt를 사용하여 안전한 비밀번호 저장 및 검증\n *\n * [사용되는 위치]\n * - 회원가입 API: 비밀번호 해싱\n * - 로그인 API: 비밀번호 검증\n * - 비밀번호 재설정 API: 비밀번호 해싱\n *\n * [주의사항]\n * - bcrypt 패키지가 설치되어 있어야 함 (npm install bcrypt @types/bcrypt)\n * - saltRounds는 보안과 성능의 균형을 고려하여 10~12 권장\n */\n\nimport bcrypt from \"bcrypt\";\n\n// Salt Rounds (해싱 복잡도, 높을수록 안전하지만 느림)\nconst SALT_ROUNDS = 10;\n\n/**\n * 비밀번호를 해싱합니다.\n *\n * @param password - 평문 비밀번호\n * @returns 해싱된 비밀번호\n *\n * @example\n * const hashedPassword = await hashPassword(\"myPassword123\");\n * // 결과: $2b$10$... (60자 해시값)\n */\nexport async function hashPassword(password: string): Promise<string> {\n  try {\n    const hashedPassword = await bcrypt.hash(password, SALT_ROUNDS);\n    return hashedPassword;\n  } catch (error) {\n    console.error(\"[hashPassword] 비밀번호 해싱 실패:\", error);\n    throw new Error(\"비밀번호 해싱에 실패했습니다.\");\n  }\n}\n\n/**\n * 평문 비밀번호와 해시된 비밀번호를 비교합니다.\n *\n * @param password - 평문 비밀번호\n * @param hashedPassword - 해시된 비밀번호 (DB에 저장된 값)\n * @returns 일치 여부 (true/false)\n *\n * @example\n * const isValid = await verifyPassword(\"myPassword123\", hashedPasswordFromDB);\n * if (isValid) {\n *   // 로그인 성공\n * }\n */\nexport async function verifyPassword(\n  password: string,\n  hashedPassword: string\n): Promise<boolean> {\n  try {\n    const isMatch = await bcrypt.compare(password, hashedPassword);\n    return isMatch;\n  } catch (error) {\n    console.error(\"[verifyPassword] 비밀번호 검증 실패:\", error);\n    return false;\n  }\n}\n\n/**\n * 비밀번호 강도를 검증합니다.\n *\n * @param password - 검증할 비밀번호\n * @returns 검증 결과 { valid: boolean, message?: string }\n *\n * 규칙:\n * - 최소 6자 이상\n * - (선택) 영문, 숫자 포함 권장\n *\n * @example\n * const result = validatePasswordStrength(\"abc123\");\n * if (!result.valid) {\n *   console.log(result.message); // \"비밀번호는 최소 6자 이상이어야 합니다.\"\n * }\n */\nexport function validatePasswordStrength(password: string): {\n  valid: boolean;\n  message?: string;\n} {\n  // 최소 길이 검증\n  if (password.length < 6) {\n    return {\n      valid: false,\n      message: \"비밀번호는 최소 6자 이상이어야 합니다.\",\n    };\n  }\n\n  // 추가 검증 규칙 (필요시 활성화)\n  // const hasLetter = /[a-zA-Z]/.test(password);\n  // const hasNumber = /[0-9]/.test(password);\n  // if (!hasLetter || !hasNumber) {\n  //   return {\n  //     valid: false,\n  //     message: \"비밀번호는 영문과 숫자를 포함해야 합니다.\",\n  //   };\n  // }\n\n  return { valid: true };\n}\n","// src/backend/jobs/fetchTodaySleepRaw.ts\n/**\n * 오늘 수면 점수를 계산하기 위해 Firestore에서\n * \"어제 밤 ~ 오늘 아침\" 구간의 raw_periodic 데이터를 가져오는 모듈.\n *\n * [로직]\n * - 수면은 보통 22시~10시 사이 발생한다고 가정\n * - 오늘 날짜 기준:\n *      어제 22:00 (start)\n *      오늘 10:00 (end)\n *\n * [주의]\n * - 이 범위는 기본값이며, 나중에 사용자별 취침 패턴에 맞춰 조정 가능\n */\n\nimport { db } from \"@/lib/firebase/client\";\nimport { collection, query, where, getDocs } from \"firebase/firestore\";\nimport type { PeriodicRaw } from \"@/lib/types/periodic\";\n\nexport async function fetchTodaySleepRaw(userId: string): Promise<PeriodicRaw[]> {\n  const now = new Date();\n\n  // 오늘 10시\n  const end = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 10, 0, 0);\n  // 어제 22시\n  const start = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1, 22, 0, 0);\n\n  const col = collection(db, \"users\", userId, \"raw_periodic\");\n  const q = query(\n    col,\n    where(\"timestamp\", \">=\", start.getTime()),\n    where(\"timestamp\", \"<=\", end.getTime())\n  );\n\n  const snap = await getDocs(q);\n  const data: PeriodicRaw[] = [];\n\n  snap.forEach((doc) => {\n    data.push({ ...(doc.data() as PeriodicRaw), id: doc.id });\n  });\n\n  return data;\n}\n","// src/backend/jobs/sleepSessionDetector.ts\n/**\n * [파일 역할]\n *\n * - Firestore raw_periodic 데이터를 \"수면 에포크(SleepEpoch)\"로 변환하고\n * - 에포크들을 묶어서 \"수면 세션(SleepSession)\"을 검출하는 모듈입니다.\n *\n * [전체 흐름]\n * 1) PeriodicRaw[] (raw_periodic 문서들)\n * 2) buildSleepEpochs(raws) → SleepEpoch[]\n * 3) detectSleepSessions(epochs) → SleepSession[]\n *\n * [주의사항]\n * - 이 파일은 \"수면 여부/단계 판정\"과 \"수면 세션 분할\"만 담당합니다.\n * - 최종 점수(0~100) 계산은 lib/sleep/calculateDailySleepScore.ts에서 담당합니다.\n */\n\nimport type { PeriodicRaw } from \"@/lib/types/periodic\";\n\n/** 수면 단계 타입 정의 */\nexport type SleepStage = \"DEEP\" | \"LIGHT\" | \"REM\" | \"AWAKE\";\n\n/**\n * SleepEpoch\n *\n * - raw_periodic 1개를 \"수면 단계가 라벨링 된 샘플\"로 확장한 구조입니다.\n * - duration(길이)은 raw_periodic 수집 주기(예: 10분)를 가정합니다.\n */\nexport interface SleepEpoch {\n  /** Firestore 문서 id (옵션) */\n  id?: string;\n\n  /** 샘플 수집 시각 (epoch ms) */\n  timestamp: number;\n\n  /** 분류된 수면 단계 */\n  stage: SleepStage;\n\n  /** 아래는 raw 측정값 그대로 복사 */\n  heart_rate_avg: number;\n  heart_rate_min?: number;\n  movement_count: number;\n  respiratory_rate_avg: number;\n  hrv_sdnn: number;\n}\n\n/**\n * [내부 함수] 단일 PeriodicRaw → SleepStage 분류\n *\n * 매우 단순한 휴리스틱 규칙:\n * - Deep: HR(또는 HR_min) < 50 && movement <= 1\n * - REM : movement <= 1 && 호흡수 높음(>=17)\n * - Light: movement <= 4 (깊은 수면 / 각성 중간 단계)\n * - Awake: 그 외 (움직임이 많거나 HR 높은 경우)\n */\nfunction classifyStage(raw: PeriodicRaw): SleepStage {\n  const { heart_rate_avg, heart_rate_min, movement_count, respiratory_rate_avg } = raw;\n\n  // 깊은 수면 (심박 낮고 거의 안 움직임)\n  if ((heart_rate_min ?? heart_rate_avg) < 50 && movement_count <= 1) {\n    return \"DEEP\";\n  }\n\n  // REM 수면 (움직임 거의 없지만 호흡수/심박 변동이 있음)\n  if (movement_count <= 1 && respiratory_rate_avg >= 17) {\n    return \"REM\";\n  }\n\n  // 가벼운 수면 (조금 움직이지만 완전 깬 상태는 아님)\n  if (movement_count <= 4) {\n    return \"LIGHT\";\n  }\n\n  // 그 외는 각성 상태로 판단\n  return \"AWAKE\";\n}\n\n/**\n * PeriodicRaw[] → SleepEpoch[]\n *\n * [역할]\n * - timestamp 기준으로 정렬\n * - 각 원소에 대해 classifyStage() 호출해서 stage 할당\n * - 이후 수면 세션 검출 알고리즘에서 이 배열을 사용\n */\nexport function buildSleepEpochs(raws: PeriodicRaw[]): SleepEpoch[] {\n  return raws\n    .slice() // 원본 배열 변형 방지용 얕은 복사\n    .sort((a, b) => a.timestamp - b.timestamp)\n    .map((r) => ({\n      id: r.id,\n      timestamp: r.timestamp,\n      stage: classifyStage(r),\n      heart_rate_avg: r.heart_rate_avg,\n      heart_rate_min: r.heart_rate_min,\n      movement_count: r.movement_count,\n      respiratory_rate_avg: r.respiratory_rate_avg,\n      hrv_sdnn: r.hrv_sdnn,\n    }));\n}\n\n/**\n * SleepSession\n *\n * - 연속된 SleepEpoch 묶음 (한 번의 수면 블록)\n * - start~end, 총 수면 시간, 단계별 카운트 등을 포함\n */\nexport interface SleepSession {\n  /** 세션 시작 시각 (ms) */\n  start: number;\n  /** 세션 종료 시각 (ms) */\n  end: number;\n  /** 세션 길이 (분 단위) */\n  durationMinutes: number;\n\n  /** 세션을 구성하는 모든 Epoch */\n  epochs: SleepEpoch[];\n\n  /** 단계별 Epoch 수 (최종 점수 계산에 사용) */\n  stageStats: {\n    DEEP: number;\n    LIGHT: number;\n    REM: number;\n    AWAKE: number;\n  };\n}\n\n/**\n * SleepEpoch[] → SleepSession[]\n *\n * [알고리즘 개요]\n * - AWAKE가 아닌 epoch들을 연속 구간으로 묶어서 candidate 세션을 만들고\n * - 최소 길이 조건(예: 3 epoch 이상, 약 30분 이상)을 만족하는 구간만 세션으로 인정.\n */\nexport function detectSleepSessions(epochs: SleepEpoch[]): SleepSession[] {\n  if (epochs.length === 0) return [];\n\n  const sessions: SleepSession[] = [];\n  let current: SleepEpoch[] = [];\n\n  // 수면으로 취급하는 조건 (AWAKE가 아니면 모두 수면으로 간주)\n  const isSleep = (stage: SleepStage) => stage !== \"AWAKE\";\n\n  for (const e of epochs) {\n    if (isSleep(e.stage)) {\n      // 수면 상태: 현재 세션에 계속 추가\n      current.push(e);\n    } else {\n      // 각성 상태로 전환된 시점:\n      // 지금까지 누적된 current가 충분히 길면 하나의 세션으로 저장\n      if (current.length >= 3) {\n        sessions.push(makeSession(current));\n      }\n      // current 초기화\n      current = [];\n    }\n  }\n\n  // 루프 끝나고도 남아 있는 수면 덩어리 처리\n  if (current.length >= 3) {\n    sessions.push(makeSession(current));\n  }\n\n  return sessions;\n}\n\n/**\n * [내부 함수]\n * - 연속된 SleepEpoch 배열 → SleepSession 1개로 변환\n */\nfunction makeSession(epochs: SleepEpoch[]): SleepSession {\n  const start = epochs[0].timestamp;\n  const end = epochs[epochs.length - 1].timestamp;\n\n  // ms → 분 단위\n  const durationMinutes = (end - start) / 1000 / 60;\n\n  // 단계별 개수 집계\n  const stats = { DEEP: 0, LIGHT: 0, REM: 0, AWAKE: 0 };\n  epochs.forEach((e) => {\n    stats[e.stage] += 1;\n  });\n\n  return {\n    start,\n    end,\n    durationMinutes,\n    epochs,\n    stageStats: stats,\n  };\n}\n","// src/lib/sleep/calculateDailySleepScore.ts\n/**\n * [파일 역할]\n *\n * - 하나의 SleepSession(한 번의 수면 블록)을 입력으로 받아\n *   \"하루 수면 점수(0~100)\"를 계산하는 모듈입니다.\n *\n * [점수 구성]\n * - 총 수면 시간 점수 (50%)\n * - 수면 단계 구성 점수 (30%)\n * - 수면 품질 점수 (20%)  → 각성 비율 낮을수록 고득점\n */\n\nimport type { SleepSession } from \"@/backend/jobs/sleepSessionDetector\";\n\n/**\n * 수면 점수 계산 결과 타입\n * - score: 최종 0~100 점수\n * - components: 세부 구성 요소 (디버깅용 / 분석용)\n */\nexport interface DailySleepScoreResult {\n  score: number;\n  components: {\n    /** 총 수면 시간 점수 (0~1) */\n    totalSleepScore: number;\n    /** 단계 구성 점수 (0~1) */\n    stageScore: number;\n    /** 각성 비율 기반 품질 점수 (0~1) */\n    qualityScore: number;\n  };\n}\n\n/**\n * SleepSession → 하루 수면 점수(0~100)\n */\nexport function calculateDailySleepScore(session: SleepSession): DailySleepScoreResult {\n  const { durationMinutes, stageStats } = session;\n\n  // ---------------------------------------------------------------------------\n  // 1) 총 수면 시간 점수 (50%)\n  // ---------------------------------------------------------------------------\n  const hours = durationMinutes / 60;\n  // 8시간 수면을 이상적인 기준(=1.0)으로 잡고, 그 이하면 비례 점수\n  const totalSleepScore = Math.min(hours / 8, 1);\n\n  // ---------------------------------------------------------------------------\n  // 2) 수면 단계 구성 점수 (30%)\n  //    - Deep, REM 비율이 높을수록 고득점\n  // ---------------------------------------------------------------------------\n  const totalEpochs =\n    stageStats.DEEP + stageStats.LIGHT + stageStats.REM + stageStats.AWAKE || 1; // 0 나누기 방지\n\n  const deepRatio = stageStats.DEEP / totalEpochs;\n  const remRatio = stageStats.REM / totalEpochs;\n\n  // Deep 비중 60%, REM 비중 40% 반영 후 스케일 업(최대 1.0로 clamp)\n  const stageScore = Math.min((deepRatio * 0.6 + remRatio * 0.4) * 2, 1);\n\n  // ---------------------------------------------------------------------------\n  // 3) 수면 품질 점수 (20%)\n  //    - AWAKE 비율이 낮을수록 점수↑\n  // ---------------------------------------------------------------------------\n  const awakeRatio = stageStats.AWAKE / totalEpochs;\n  // AWAKE가 0이면 1점, 0.5면 0점, 그 이상이면 0으로 바닥\n  const qualityScore = Math.max(1 - awakeRatio * 2, 0);\n\n  // ---------------------------------------------------------------------------\n  // 4) 최종 가중합 (0~1) → 0~100 변환\n  // ---------------------------------------------------------------------------\n  const final0to1 =\n    totalSleepScore * 0.5 +\n    stageScore * 0.3 +\n    qualityScore * 0.2;\n\n  const finalScore = Math.round(final0to1 * 100);\n\n  return {\n    score: finalScore,\n    components: {\n      totalSleepScore,\n      stageScore,\n      qualityScore,\n    },\n  };\n}\n","// src/backend/jobs/calcTodaySleepScore.ts\n/**\n * [파일 역할]\n *\n * - \"오늘 수면 점수\"를 계산하는 상위 오케스트레이터 모듈입니다.\n *\n * [파이프라인]\n * 1) fetchTodaySleepRaw(userId)\n *    → 어제 22시 ~ 오늘 10시에 해당하는 raw_periodic 가져오기\n * 2) buildSleepEpochs(raws)\n *    → 수면 단계가 태깅된 SleepEpoch[] 생성\n * 3) detectSleepSessions(epochs)\n *    → SleepSession[] 검출\n * 4) 가장 긴 세션 선택 (주 수면 세션)\n * 5) calculateDailySleepScore(longest)\n *    → 0~100 점수 산출\n */\n\nimport { fetchTodaySleepRaw } from \"./fetchTodaySleepRaw\";\nimport {\n  buildSleepEpochs,\n  detectSleepSessions,\n  type SleepSession,\n} from \"./sleepSessionDetector\";\nimport { calculateDailySleepScore } from \"@/lib/sleep/calculateDailySleepScore\";\n\n// [EDIT] 반환 타입 명시적 정의 추가 (타입 에러 해결을 위해)\nexport type CalcTodaySleepScoreResult =\n  | {\n      score: null;\n      reason: \"NO_DATA\" | \"NO_SESSION\";\n    }\n  | {\n      score: number;\n      totalMinutes: number;\n      stageStats: SleepSession[\"stageStats\"];\n      components: ReturnType<typeof calculateDailySleepScore>[\"components\"];\n    };\n\nexport async function calcTodaySleepScore(\n  userId: string\n): Promise<CalcTodaySleepScoreResult> {\n  // 1) Firestore에서 오늘 분석 대상 raw 데이터 가져오기\n  const raw = await fetchTodaySleepRaw(userId);\n\n  // 분석할 데이터가 하나도 없는 경우\n  if (raw.length === 0) {\n    return { score: null, reason: \"NO_DATA\" as const };\n  }\n\n  // 2) SleepEpoch 생성 (수면 단계 라벨링)\n  const epochs = buildSleepEpochs(raw);\n\n  // 3) 수면 세션 검출\n  const sessions = detectSleepSessions(epochs);\n  if (sessions.length === 0) {\n    return { score: null, reason: \"NO_SESSION\" as const };\n  }\n\n  // 4) 가장 긴 수면 세션을 \"주 수면\"으로 선택\n  const longest = sessions.reduce((a, b) =>\n    a.durationMinutes > b.durationMinutes ? a : b\n  );\n\n  // 5) 선택된 세션을 기반으로 하루 수면 점수 계산\n  const result = calculateDailySleepScore(longest);\n\n  return {\n    score: result.score,              // 최종 수면 점수 (0~100)\n    totalMinutes: longest.durationMinutes,\n    stageStats: longest.stageStats,\n    components: result.components,    // 디버깅/분석용 세부 점수\n  };\n}\n"],"names":[],"mappings":"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"}